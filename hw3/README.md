# Домашня робота №3

## Завдання

- Наведіть приклад інтерфейсу, що порушує ISP та запропонуйте вирішення проблеми.
- Покажіть, які переваги має застосування DIP (через Dependency Injection).
- Поясніть, як "вузькі" інтерфейси (ISP) сприяють кращому DI та тестуванню.

### Приклад порушення ISP та рефакторинг

Перед тим як надати приклад, потрібно зрозуміти, ISP - це принцип розділення інтерфейсів, тобто це принцип який говорить, що краще багато меньших інтерфейсів ніж один `God interface`. В реалізаціях цього інтерфесу можуть бути не потрібно деякі методи, і тоді приходиться просто робити непотрібні реалізації.

```csharp
// Приклад поганого ISP
interface IWorked
{
    void Work();
    void Eat();
    void Sleep();
}
```

Цей уривок коду як раз описує той самий `God interface`, який хоче все та відразу. Наприклад є у них реалізація `HumanWorker` та `RobotWorker`, і так як роботу не потрібно спати, то йому не потрібен метод `Sleep()`.

```csharp
// Рефакторинг
public interface IWorkable
{
    void Work();
}

public interface IEatable
{
    void Eat();
}

public interface ISleepable
{
    void Sleep();
}
```

В цьому прикладі інтрефейс `IWorked` розбитий на декілька класів. Цей франгмент коду дотримується `ISP`, тому що кожен інтерфейс відповідає саме за потрібний метод, і не може бути моментів із противоріччям, як у першому варіанті.

### Які переваги має DIP

#### що таке DIP

DIP вимагає що б модулі залежали від абстракцій, а конкретні реалізації передавались ззовні (DI). Dependency Injection як раз таки і передає ці залежності ззовні, і дозволяє реалізувати DIP.

#### Основні переваги

- Клас не створює залежності а лише працює із інтерфейсом.
- Покращена тестовість, можна створювати заглушик (mock) або якісь фейки.
- Набагато швидше пишуться unit-тести.
- Дотримання SRP, так як відповідає тільки за свою логіку.
- Краща читабельність коду.
- Відповідає сучасним архітектурам.
- Дуже хороша масштабованість.

Приклад DIP через `(Dependency Injection)`

```csharp
// Реалізація IWorkable
public class HumanWorker : IWorkable
{
    public void Work()
    {
        Console.WriteLine("Людина працює");
    }
}

// Сервіс для Work
public class WorkService
{
    private readonly IWorkable _worker;

    public WorkService(IWorkable worker)
    {
        _worker = worker;
    }

    public void Menager()
    {
        _worker.Work();
    }
}

// Використання DI
IWorkable workerHuman = new HumanWorker();

var menager = new WorkService(workerHuman);
menager.Menager();
```

### Як ISP сприяє кращому тестуваню DI

- Вузькі інтерфейси простіші залежності в DI, тому що він потребує менше функіоналу і його залежність чітко зрозумліа.
- Меньше зайвих реалізацій.
- Ізольоване unit-тестування, ISP дозволяє ізолювати одну відповідальність та тестувати клас без побічних ефектів.
- Легча заміша реалізацій, тому що вона підставляється ззовні.
- Менше поганих тестів, у ISP зміни більш локалізовані.
- Краще розуміння залежності класу.
