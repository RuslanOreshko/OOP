# Лабораторна робота №20

## Тема: SRP: декомпозиція OrderProcessor.

### Завдання

- Реалізувати початковий клас OrderProcessor (порушує SRP).
- Виконати рефакторинг OrderProcessor для дотримання SRP.
- Продемонструвати роботу в методі Main.

### Виконання 

### 1. Реалізувати початковий клас OrderProcessor (порушує SRP).
Для початку варто створити клас `Order` (Зразок із документації). Після Створити початковий клас `OrderProcessor` який приймає об'єкт класу `Order`. Клас має порушувати принцип єдиної відповідальності. Знизу скрнішот класу:

- ![alt text](Images/image.png)

В скріншоті продемонстровано:

Метод `ProcessorOrder` імітує валідацію, момент коли виводиться 'Замовлення прийнято!'.
Також він імітує логування Бази даних, та повідомлення від Email. В кінці метод оновлює статус.

Чому цей клас порушує принцим SRP? А саме тому, що він на себе багато відповідальності.

Результат виводу цього пракладу коду в консоль.

![alt text](Images/image-2.png)

### 2. Виконати рефакторинг OrderProcessor для дотримання SRP.

Для того що б наша програма відповідала критеріям SRP вона повинна бути розділенна на кілька компонентів:

- Інтерфейси та їх реалізації;
- Заглушки `(mock implementations)` для інтерфeйсів;
- Новий `DI` клас `OrderService`;

#### інтерфейси та їх реалізації:

було створено три інтерфейси, які відповідають тим, що були вказані в документації:

- ![alt text](Images/image-3.png)

Приклад одного із них:

- ![alt text](Images/image-4.png)

Їх реалізації показані в розділі "Заглушки `(mock implementations)` для інтерфeйсів"

#### Заглушки `(mock implementations)` для інтерфeйсів:

Відмінно від прикладу із документації було створено заглушку `Validator`, і інші дві `ConsoleEmailService` та `InMemoryRepository`:

- ![alt text](Images/image-5.png)

Скріншоти заглушок:


- ![alt text](Images/image-6.png) `InMemoryRepository`

- ![alt text](Images/image-7.png) `ConsoleEmailService`

- ![alt text](Images/image-8.png) `Validator` 

#### Новий `DI` клас `OrderService`;

Клас збирає використовує заглушки, та використовує через свій конструктор `Dependency Injection` який було інстальвано в `dotnet package`:

![alt text](Images/image-1.png)

Нижче скріншот класу 

- ![alt text](Images/image-9.png)

Але сам `DI` був зібраний в окремому фалі `Program.cs`, де через `IServiceCollection` був зібраний контейнер, через який можна встановлювати час життя окремих кусків програми.

- ![alt text](Images/image-10.png)

### 3. Продемонструвати роботу в методі Main.

Як уже зрозуміло демострація не через метод `Main()` а через `DI` в `Program.cs`.

- ![alt text](Images/image-11.png)

### Результати (вивід у консоль):

- ![alt text](Images/image-12.png)